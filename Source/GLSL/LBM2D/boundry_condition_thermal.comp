#<compute shader>

#version 460 core

#define D2Q9 0
#define D3Q15 1
#define D3Q19 2
#define D3Q27 3

#define fp16 0
#define fp32 1

#define floating_point_accuracy fp32
#define velocity_set D2Q9

#define boundry_count 1
#define bits_per_boundry 0

#if velocity_set == D2Q9
	#define volume_dimentionality 2
	#define velocity_count 9
#elif velocity_set == D3Q15
	#define volume_dimentionality 3
	#define velocity_count 15
#elif velocity_set == D3Q19
	#define volume_dimentionality 3
	#define velocity_count 19
#elif velocity_set == D3Q27
	#define volume_dimentionality 3
	#define velocity_count 27
#else
	#error "velocity set is not supported"
#endif

#if floating_point_accuracy == fp32
#else
	#error "other floating point systems than fp32 aren't supported"
#endif

#define D2Q5 4
#define D3Q7 5

#define thermal_flow 0
#define velocity_set_thermal D2Q5

#if velocity_set_thermal == D2Q5
	#define thermal_velocity_count 5
#elif velocity_set_thermal == D3Q7
	#define thermal_velocity_count 7
#else
	#error "thermal_velocity_set is not supported"
#endif

#define multiphase_flow 1

#define id gl_GlobalInvocationID

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

#if thermal_flow == 1
layout(std140, binding = 0) uniform thermal_velocity_set_buffer {
	vec4[thermal_velocity_count] thermal_lattice_velocity_set;
};

layout(std430, binding = 1) buffer thermal_lattice_buffer {
	float[] thermal_lattice;
};
#endif

#if boundry_count > 1
layout(std430, binding = 2) buffer boundries_buffer {
	uint[] boundries;
};

layout(std430, binding = 3) buffer objects_buffer {
	vec4[] objects;
};
#endif

uniform ivec2 lattice_resolution;

#if thermal_flow == 1
int get_inverse_lattice_direction_index_thermal(int lattice_velocity_index){
	if (lattice_velocity_index == 0 || lattice_velocity_index >= thermal_velocity_count)
		return 0;

	bool is_odd = lattice_velocity_index % 2 == 1;
	return is_odd ? lattice_velocity_index + 1 : lattice_velocity_index - 1;
}

vec3 get_lattice_velocity_thermal(int velocity_index){
	return thermal_lattice_velocity_set[velocity_index].xyz;
}

float get_lattice_weight_thermal(int velocity_index){
	return thermal_lattice_velocity_set[velocity_index].w;
}
#endif

uint get_boundry(ivec2 pixel_coord) {
#if boundry_count > 1

	uint voxel_id = pixel_coord.y * lattice_resolution.x + pixel_coord.x;
	uint bits_begin = voxel_id * bits_per_boundry;
			
	uint dword_offset = bits_begin / 32;
	uint subdword_offset_in_bits = bits_begin % 32;
	
	uint bitmask = (1 << bits_per_boundry) - 1;
	uint boundry = boundries[dword_offset] & (bitmask << subdword_offset_in_bits);
	boundry = boundry >> subdword_offset_in_bits;
		
	return boundry;
#else
	return 0;
#endif
}

struct object_info_s {
	vec3 velocity;
	vec3 center_of_mass;
	vec3 velocity_angular;
	float temperature;
	float effective_density;
};

object_info_s get_object_info(int object_id){
#if boundry_count > 1
	object_info_s result;
	result.temperature		 =	objects[object_id * 3 + 0].w;
	result.velocity			 =	objects[object_id * 3 + 0].xyz;
	result.center_of_mass	 =	objects[object_id * 3 + 1].xyz;
	result.velocity_angular  =	objects[object_id * 3 + 2].xyz;
	result.effective_density =	objects[object_id * 3 + 2].w;
	return result;
#else 
	object_info_s result;
	result.temperature		 =	0;
	result.velocity			 =	vec3(0);
	result.center_of_mass	 =	vec3(0);
	result.velocity_angular  =	vec3(0);
	result.effective_density =	0;
	return result;
#endif
}

#if thermal_flow == 1
float dirichlet_boundry_correction_term(int lattice_velocity_index, float boundry_temperature){
	vec3 c = get_lattice_velocity_thermal(lattice_velocity_index);
	float w = get_lattice_weight_thermal(lattice_velocity_index);
	float t = boundry_temperature;
	//float cs = 1.0 / sqrt(3);
	//float cs2 = pow(1.0 / sqrt(3), 2);

	return +2 * w * t; 
}
#endif

void main(){
	
	if (id.x >= lattice_resolution.x * lattice_resolution.y)
		return;
	
	int pixel_id = int(id.x);
	ivec2 pixel_coord = ivec2(pixel_id.x % lattice_resolution.x, pixel_id.x / lattice_resolution.x);
	
	int boundry = int(get_boundry(pixel_coord));
	if (boundry == 0)
		return;

	object_info_s object = get_object_info(boundry);
	// include angular velocity term
	float boundry_temperature = object.temperature;

	#if thermal_flow == 1
	for (int population_id = 1; population_id < thermal_velocity_count; population_id+=2)
	{
		int inv_population_id = get_inverse_lattice_direction_index_thermal(population_id);
		
		float value_a = thermal_lattice[pixel_id * thermal_velocity_count + population_id];
		float value_b = thermal_lattice[pixel_id * thermal_velocity_count + inv_population_id];
		
		thermal_lattice[pixel_id * thermal_velocity_count + population_id]		= -value_b + dirichlet_boundry_correction_term(inv_population_id, boundry_temperature);
		thermal_lattice[pixel_id * thermal_velocity_count + inv_population_id]	= -value_a + dirichlet_boundry_correction_term(population_id, boundry_temperature);
	}
	#endif
}